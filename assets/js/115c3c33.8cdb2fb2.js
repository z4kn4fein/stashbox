"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[196],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294),i=n(6010);const r="tabItem_Ymn6";function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,o),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>m});var a=n(7462),i=n(7294),r=n(6010),o=n(2389),s=n(7392),l=n(7094),c=n(2466);const p="tabList__CuJ",d="tabItem_LNqP";function u(e){const{lazy:t,block:n,defaultValue:o,values:u,groupId:m,className:h}=e,v=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=u??v.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),y=(0,s.l)(g,((e,t)=>e.value===t.value));if(y.length>0)throw new Error(`Docusaurus error: Duplicate values "${y.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const f=null===o?o:o??v.find((e=>e.props.default))?.props.value??v[0].props.value;if(null!==f&&!g.some((e=>e.value===f)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${f}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:N}=(0,l.U)(),[b,w]=(0,i.useState)(f),x=[],{blockElementScrollPositionUntilNextRender:S}=(0,c.o5)();if(null!=m){const e=k[m];null!=e&&e!==b&&g.some((t=>t.value===e))&&w(e)}const C=e=>{const t=e.currentTarget,n=x.indexOf(t),a=g[n].value;a!==b&&(S(t),w(a),null!=m&&N(m,String(a)))},T=e=>{let t=null;switch(e.key){case"Enter":C(e);break;case"ArrowRight":{const n=x.indexOf(e.currentTarget)+1;t=x[n]??x[0];break}case"ArrowLeft":{const n=x.indexOf(e.currentTarget)-1;t=x[n]??x[x.length-1];break}}t?.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",p)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},h)},g.map((e=>{let{value:t,label:n,attributes:o}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:b===t?0:-1,"aria-selected":b===t,key:t,ref:e=>x.push(e),onKeyDown:T,onClick:C},o,{className:(0,r.Z)("tabs__item",d,o?.className,{"tabs__item--active":b===t})}),n??t)}))),t?(0,i.cloneElement)(v.filter((e=>e.props.value===b))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},v.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==b})))))}function m(e){const t=(0,o.Z)();return i.createElement(u,(0,a.Z)({key:String(t)},e))}},8243:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=n(7462),i=(n(7294),n(3905)),r=n(5488),o=n(5162);const s={},l="Validation",c={unversionedId:"diagnostics/validation",id:"diagnostics/validation",title:"Validation",description:"Stashbox has validation routines that help you detect and solve common misconfiguration issues. You can verify the container's actual state with its .Validate() method. This method walks through the whole resolution tree and collects all the issues into an AggregateException.",source:"@site/docs/diagnostics/validation.md",sourceDirName:"diagnostics",slug:"/diagnostics/validation",permalink:"/stashbox/docs/diagnostics/validation",draft:!1,editUrl:"https://github.com/z4kn4fein/stashbox/edit/master/docs/docs/diagnostics/validation.md",tags:[],version:"current",lastUpdatedBy:"Peter Csajtai",lastUpdatedAt:1672689765,formattedLastUpdatedAt:"Jan 2, 2023",frontMatter:{},sidebar:"docs",previous:{title:"Special resolution cases",permalink:"/stashbox/docs/advanced/special-resolution-cases"},next:{title:"Utilities",permalink:"/stashbox/docs/diagnostics/utilities"}},p={},d=[{value:"Registration validation",id:"registration-validation",level:2},{value:"InvalidRegistrationException",id:"invalidregistrationexception",level:3},{value:"ServiceAlreadyRegisteredException",id:"servicealreadyregisteredexception",level:3},{value:"Resolution validation",id:"resolution-validation",level:2},{value:"Lifetime validation",id:"lifetime-validation",level:2},{value:"Circular dependency",id:"circular-dependency",level:2},{value:"Other exceptions",id:"other-exceptions",level:2},{value:"CompositionRootNotFoundException",id:"compositionrootnotfoundexception",level:3},{value:"ConstructorNotFoundException",id:"constructornotfoundexception",level:3}],u={toc:d};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"validation"},"Validation"),(0,i.kt)("p",null,"Stashbox has validation routines that help you detect and solve common misconfiguration issues. You can verify the container's actual state with its ",(0,i.kt)("inlineCode",{parentName:"p"},".Validate()")," method. This method walks through the whole ",(0,i.kt)("a",{parentName:"p",href:"/docs/getting-started/glossary#resolution-tree"},"resolution tree")," and collects all the issues into an ",(0,i.kt)("inlineCode",{parentName:"p"},"AggregateException"),"."),(0,i.kt)("h2",{id:"registration-validation"},"Registration validation"),(0,i.kt)("p",null,"The container validates the given types during registration and throws the following exceptions when the validation fails."),(0,i.kt)("h3",{id:"invalidregistrationexception"},"InvalidRegistrationException"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"When the ",(0,i.kt)("a",{parentName:"em",href:"/docs/getting-started/glossary#service-type--implementation-type"},"implementation type")," is not resolvable:")," (it's an interface or abstract class registered like: ",(0,i.kt)("inlineCode",{parentName:"li"},"Register<IService>()"),"):",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"The type Namespace.IService could not be resolved. It's probably an interface, abstract class, or primitive type.\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"When the ",(0,i.kt)("a",{parentName:"em",href:"/docs/getting-started/glossary#service-type--implementation-type"},"implementation type")," does not implement the ",(0,i.kt)("a",{parentName:"em",href:"/docs/getting-started/glossary#service-type--implementation-type"},"service type")),":",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"The type Namespace.MotorCycle does not implement the '[service type](/docs/getting-started/glossary#service-type--implementation-type)' Namespace.ICar.\n")))),(0,i.kt)("h3",{id:"servicealreadyregisteredexception"},"ServiceAlreadyRegisteredException"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"When the given ",(0,i.kt)("a",{parentName:"em",href:"/docs/getting-started/glossary#service-type--implementation-type"},"implementation type")," is already registered")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"RegistrationBehavior")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/configuration/container-configuration#registration-behavior"},"container configuration option")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"ThrowException"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"The type Namespace.Service is already registered.\n")),(0,i.kt)("h2",{id:"resolution-validation"},"Resolution validation"),(0,i.kt)("p",null,"During the construction of the ",(0,i.kt)("a",{parentName:"p",href:"/docs/getting-started/glossary#resolution-tree"},"resolution tree"),", the container continuously checks its actual state to ensure stability. When any of the following issues occur, the container throws a ",(0,i.kt)("inlineCode",{parentName:"p"},"ResolutionFailedException"),"."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"When a dependency is missing from the ",(0,i.kt)("a",{parentName:"em",href:"/docs/getting-started/glossary#resolution-tree"},"resolution tree")),":"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"Parameter",label:"Parameter",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"class Service\n{\n    public Service(Dependency dep) { }\n\n    public Service(Dependency2 dep2) { }\n}\n\ncontainer.Register<Service>();\nvar service = container.Resolve<Service>();\n")),(0,i.kt)("p",{parentName:"li"},"This will result in the following exception message:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"Could not resolve type Namespace.Service.\nConstructor Void .ctor(Dependency) found with unresolvable parameter: (Namespace.Dependency)dep.\nConstructor Void .ctor(Dependency2) found with unresolvable parameter: (Namespace.Dependency2)dep2.\n"))),(0,i.kt)(o.Z,{value:"Property / field",label:"Property / field",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"class Service\n{\n    public Dependency Dep { get; set; }\n}\n\ncontainer.Register<Service>(options => options.WithDependencyBinding(s => s.Dep));\nvar service = container.Resolve<Service>();\n")),(0,i.kt)("p",{parentName:"li"},"This will show the following message:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"Could not resolve type Namespace.Service.\nUnresolvable property: (Namespace.Dependency)Dep.\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"When the requested type is unresolvable:")," (e.g., it doesn't have a public constructor)"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"Could not resolve type Namespace.Service.\nService is not registered or unresolvable type requested.\n")))),(0,i.kt)("h2",{id:"lifetime-validation"},"Lifetime validation"),(0,i.kt)("p",null,"This validation enforces the following rules, and when they are being violated, the container throws a ",(0,i.kt)("inlineCode",{parentName:"p"},"LifetimeValidationFailedException"),"."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"When a scoped service is requested from the ",(0,i.kt)("a",{parentName:"em",href:"/docs/getting-started/glossary#root-scope"},"root scope")),". As the ",(0,i.kt)("a",{parentName:"p",href:"/docs/getting-started/glossary#root-scope"},"root scope's")," lifetime is bound to the container's lifetime, this action would unintentionally promote the scoped service's lifetime to singleton:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"Resolution of Namespace.Service (ScopedLifetime) from the '[root scope](/docs/getting-started/glossary#root-scope)' is not allowed, \nthat would promote the service's lifetime to a singleton.\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"When the life-span of a dependency is shorter than its parent's"),". It's called ",(0,i.kt)("a",{parentName:"p",href:"https://blog.ploeh.dk/2014/06/02/captive-dependency/"},"captive dependency"),". Every lifetime has a ",(0,i.kt)("inlineCode",{parentName:"p"},"LifeSpan")," value, which determines how long the related service lives. The main rule is that services may not contain dependencies with shorter life-spans like singletons should not depend on scoped services. The only exception is the life-span value ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", which indicates that the related service is state-less and could be injected into any service. "),(0,i.kt)("p",{parentName:"li"},"  These are the ",(0,i.kt)("inlineCode",{parentName:"p"},"LifeSpan")," values of the pre-defined lifetimes: "),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Singleton"),": 20"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Scoped"),": 10"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"NamedScope"),": 10"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"PerRequest"),": 0"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"PerScopedRequest"),": 0"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Transient"),": 0")),(0,i.kt)("p",{parentName:"li"},"In case of a failed validation the exception message would be:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"The life-span of Namespace.Service (ScopedLifetime|10) is shorter than \nits direct or indirect parent's Namespace.Dependency (Singleton|20). \nThis could lead to incidental lifetime promotions with longer life-span, \nit's recommended to double-check your lifetime configurations.\n")))),(0,i.kt)("h2",{id:"circular-dependency"},"Circular dependency"),(0,i.kt)("p",null,"When the container encounters a circular dependency loop in the ",(0,i.kt)("a",{parentName:"p",href:"/docs/getting-started/glossary#resolution-tree"},"resolution tree"),", it throws a ",(0,i.kt)("inlineCode",{parentName:"p"},"CircularDependencyException")," with every diagnostic detail included."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"class Service1\n{\n    public Service1(Service2 service2) { }\n}\n\nclass Service2\n{\n    public Service2(Service1 service1) { }\n}\n\ncontainer.Register<Service1>();\ncontainer.Register<Service2>();\nvar service = container.Resolve<Service1>();\n")),(0,i.kt)("p",null,"The exception message is:  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Circular dependency detected during the resolution of Namespace.Service1.\n")),(0,i.kt)("h2",{id:"other-exceptions"},"Other exceptions"),(0,i.kt)("h3",{id:"compositionrootnotfoundexception"},"CompositionRootNotFoundException"),(0,i.kt)("p",null,"This exception pops up when we try to compose an assembly, but it doesn't contain an ",(0,i.kt)("inlineCode",{parentName:"p"},"ICompositionRoot")," implementation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"container.ComposeAssembly(typeof(Service).Assembly);\n")),(0,i.kt)("p",null,"The exception message is:  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"No ICompositionRoot found in the given assembly: {your-assembly-name}\n")),(0,i.kt)("h3",{id:"constructornotfoundexception"},"ConstructorNotFoundException"),(0,i.kt)("p",null,"During the registration phase, when you are using the ",(0,i.kt)("inlineCode",{parentName:"p"},"WithConstructorByArgumentTypes()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"WithConstructorByArguments()")," options, you can accidentally point to a non-existing constructor and in that case, the container throws a ",(0,i.kt)("inlineCode",{parentName:"p"},"ConstructorNotFoundException"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"class Service\n{\n    public Service(Dependency dep) { }\n}\n\ncontainer.Register<Service>(options => options.WithConstructorByArgumentTypes(typeof(string), typeof(int)));\n")),(0,i.kt)("p",null,"The exception message is:  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Constructor not found for Namespace.Service with the given argument types: System.String, System.Int32.\n")))}m.isMDXComponent=!0}}]);