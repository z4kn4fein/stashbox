"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[545],{3584:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var t=i(4848),r=i(8453),s=i(7470);const a={},c="Child containers",o={id:"advanced/child-containers",title:"Child containers",description:"With child containers, you can build up parent-child relationships between containers. This means you can have a different subset of services present in a child than in the parent container.",source:"@site/docs/advanced/child-containers.md",sourceDirName:"advanced",slug:"/advanced/child-containers",permalink:"/stashbox/docs/advanced/child-containers",draft:!1,unlisted:!1,editUrl:"https://github.com/z4kn4fein/stashbox/edit/master/docs/docs/advanced/child-containers.md",tags:[],version:"current",lastUpdatedBy:"Peter Csajtai",lastUpdatedAt:1734704927,formattedLastUpdatedAt:"Dec 20, 2024",frontMatter:{},sidebar:"docs",previous:{title:"Wrappers & resolvers",permalink:"/stashbox/docs/advanced/wrappers-resolvers"},next:{title:"Special resolution cases",permalink:"/stashbox/docs/advanced/special-resolution-cases"}},l={},d=[{value:"Example",id:"example",level:2},{value:"Accessing child containers",id:"accessing-child-containers",level:2},{value:"Resolution behavior",id:"resolution-behavior",level:2},{value:"Re-building singletons",id:"re-building-singletons",level:2},{value:"Nested child containers",id:"nested-child-containers",level:2},{value:"Dispose",id:"dispose",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"child-containers",children:"Child containers"}),"\n",(0,t.jsx)(n.p,{children:"With child containers, you can build up parent-child relationships between containers. This means you can have a different subset of services present in a child than in the parent container."}),"\n",(0,t.jsxs)(n.p,{children:["When a dependency is missing from the child container during a resolution request, the parent will be asked to resolve the missing service. If it's found there, the parent will return only the service's registration, and the resolution request will jump back to the child. Also, child registrations with the same ",(0,t.jsx)(n.a,{href:"/docs/getting-started/glossary#service-type--implementation-type",children:"service type"})," will override the parent's services."]}),"\n",(0,t.jsxs)(n.p,{children:["Resolving ",(0,t.jsx)(n.code,{children:"IEnumerable<T>"})," and ",(0,t.jsx)(n.a,{href:"/docs/advanced/decorators",children:"decorators"})," also considers parent containers by default. However, this behavior can be controlled with the ",(0,t.jsx)(n.a,{href:"#resolution-behavior",children:(0,t.jsx)(n.code,{children:"ResolutionBehavior"})})," parameter."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Child containers are the foundation of the ",(0,t.jsx)(n.a,{href:"https://github.com/z4kn4fein/stashbox-extensions-dependencyinjection#multitenant",children:"ASP.NET Core multi-tenant extension"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:"Here is an example case:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"interface IDependency {}\n\nclass B : IDependency {}\nclass C : IDependency {}\n\nclass A \n{\n    public A(IDependency dependency)\n    { }\n}\n\nusing (var container = new StashboxContainer())\n{\n    // register 'A' into the parent container.\n    container.Register<A>();\n\n    // register 'B' as a dependency into the parent container.\n    container.Register<IDependency, B>();\n\n    var child = container.CreateChildContainer()\n    \n    // register 'C' as a dependency into the child container.\n    child.Register<IDependency, C>();\n    \n    // 'A' is resolved from the parent and gets\n    // 'C' as IDependency because the resolution\n    // request was initiated on the child.\n    A fromChild = child.Resolve<A>();\n\n    // 'A' gets 'B' as IDependency because the \n    // resolution request was initiated on the parent.\n    A fromParent = container.Resolve<A>();\n} // using will dispose the parent along with the child.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's see what's happening when we request ",(0,t.jsx)(n.code,{children:"A"})," from the ",(0,t.jsx)(n.em,{children:"child"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"A"})," not found in the ",(0,t.jsx)(n.em,{children:"child"}),", go up to the ",(0,t.jsx)(n.em,{children:"parent"})," and check there."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"A"})," found in the ",(0,t.jsx)(n.em,{children:"parent"}),", resolve."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"A"})," depends on ",(0,t.jsx)(n.code,{children:"IDependency"}),", go back to the ",(0,t.jsx)(n.em,{children:"child"})," and search ",(0,t.jsx)(n.code,{children:"IDependency"})," implementations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"C"})," found in the ",(0,t.jsx)(n.em,{children:"child"}),", it does not have any dependencies, instantiate."]}),"\n",(0,t.jsxs)(n.li,{children:["Inject the new ",(0,t.jsx)(n.code,{children:"C"})," instance into ",(0,t.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["All dependencies are resolved; return ",(0,t.jsx)(n.code,{children:"A"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["When we make the same request on the parent, everything will go as usual because we have all dependencies in place. ",(0,t.jsx)(n.code,{children:"B"})," will be injected into ",(0,t.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["You can ",(0,t.jsx)(n.a,{href:"/docs/configuration/container-configuration",children:"re-configure"})," child containers with the ",(0,t.jsx)(n.code,{children:".Configure()"})," method. It doesn't affect the parent container's configuration."]})}),"\n",(0,t.jsx)(n.h2,{id:"accessing-child-containers",children:"Accessing child containers"}),"\n",(0,t.jsxs)(n.p,{children:["You can identify child containers with the ",(0,t.jsx)(n.code,{children:"identifier"})," parameter of ",(0,t.jsx)(n.code,{children:"CreateChildContainer()"}),". Later, you can retrieve the given child container by passing its ID to ",(0,t.jsx)(n.code,{children:"GetChildContainer()"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using var container = new StashboxContainer();\ncontainer.CreateChildContainer("child");\n// ...\n\nvar child = container.GetChildContainer("child");\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Also, each child container created by a container is available through the ",(0,t.jsx)(n.code,{children:"IStashboxContainer.ChildContainers"})," propert."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using var container = new StashboxContainer();\ncontainer.CreateChildContainer("child1");\ncontainer.CreateChildContainer("child2");\n// ...\n\nforeach (var child in container.ChildContainers)\n{\n    var id = child.Key;\n    var childContainer = child.Value;\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"resolution-behavior",children:"Resolution behavior"}),"\n",(0,t.jsxs)(n.p,{children:["You can control which level of the container hierarchy can participate in the service resolution with the ",(0,t.jsx)(n.code,{children:"ResolutionBehavior"})," parameter."]}),"\n",(0,t.jsx)(n.p,{children:"Possible values:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Default"}),": The default behavior, it's used when the parameter is not specified. Its value is ",(0,t.jsx)(n.code,{children:"Parent | Current"}),", so the parents and the current container (which initiated the resolution request) can participate in the resolution request's service selection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Parent"}),": Indicates that parent containers (including indirect all ancestors) can participate in the resolution request's service selection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Current"}),": Indicates that the current container (which initiated the resolution request) can participate in the service selection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ParentDependency"}),": Indicates that parent containers (including indirect all ancestors) can only provide dependencies for services that are already selected for resolution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PreferEnumerableInCurrent"}),": Upon enumerable resolution, services from the current container (which initiated the resolution request) are preferred, ignoring services from parent containers."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"interface IService {}\n\nclass A : IService {}\nclass B : IService {}\n\nusing (var container = new StashboxContainer())\n{\n    // register 'A' into the parent container.\n    container.Register<IService, A>();\n\n    var child = container.CreateChildContainer()\n    \n    // register 'B' into the child container.\n    child.Register<IService, B>();\n    \n    // 'A' is resolved because only parent\n    // can participate in the resolution request.\n    IService withParent = child.Resolve<IService>(ResolutionBehavior.Parent);\n\n    // Only 'B' is in the collection because\n    // only the caller container can take part\n    // in the resolution request.\n    IEnumerable<IService> allWithCurrent = child.Resolve<IEnumerable<IService>>(ResolutionBehavior.Current);\n    \n    // Both 'A' and 'B' is in the collection\n    // because both the parent and the caller container\n    // participates in the resolution request.\n    IEnumerable<IService> all = child.Resolve<IEnumerable<IService>>(ResolutionBehavior.Current | ResolutionBehavior.Parent);\n} // using will dispose the parent along with the child.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"re-building-singletons",children:"Re-building singletons"}),"\n",(0,t.jsxs)(n.p,{children:["By default, singletons are instantiated and stored only in those containers that registered them. However, you can enable the re-instantiation of singletons in child containers with the ",(0,t.jsx)(n.code,{children:".WithReBuildSingletonsInChildContainer()"})," ",(0,t.jsx)(n.a,{href:"/docs/configuration/container-configuration#re-build-singletons-in-child-containers",children:"container configuration option"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"If it's enabled, all singletons will be re-created in those containers that initiated the resolution request. By this, re-built singletons can use overridden dependencies from child containers."}),"\n",(0,t.jsx)(n.p,{children:"Re-building in child containers does not affect the singletons instantiated in the parent container."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"interface IDependency {}\n\nclass B : IDependency {}\nclass C : IDependency {}\n\nclass A \n{\n    public A(IDependency dependency)\n    { }\n}\n\nusing (var container = new StashboxContainer(options => options.WithReBuildSingletonsInChildContainer()))\n{\n    // register 'A' as a singleton into the parent container.\n    container.RegisterSingleton<A>();\n\n    // register 'B' as a dependency into the parent container.\n    container.Register<IDependency, B>();\n\n    // 'A' gets 'B' as IDependency and will be stored\n    // in the parent container as a singleton.\n    A fromParent = container.Resolve<A>();\n\n    var child = container.CreateChildContainer();\n    \n    // register 'C' as a dependency into the child container.\n    child.Register<IDependency, C>();\n\n    // a new 'A' singleton will be created in\n    // the child container with 'C' as IDependency.\n    A fromChild = child.Resolve<A>();\n} // using will dispose the parent along with the child.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"nested-child-containers",children:"Nested child containers"}),"\n",(0,t.jsxs)(s.A,{children:[(0,t.jsx)("div",{children:(0,t.jsxs)(n.p,{children:["You can build up a hierarchical tree structure from containers by creating more child containers with the ",(0,t.jsx)(n.code,{children:".CreateChildContainer()"})," method."]})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"using var container = new StashboxContainer();\n\nvar child1 = container.CreateChildContainer();\nvar child2 = child1.CreateChildContainer();\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"dispose",children:"Dispose"}),"\n",(0,t.jsxs)(n.p,{children:["By default, the parent container's disposal also disposes its child containers. You can control this behavior with the ",(0,t.jsx)(n.code,{children:"CreateChildContainer()"})," method's ",(0,t.jsx)(n.code,{children:"attachToParent"})," boolean parameter."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"using (var container = new StashboxContainer())\n{\n    using (var child1 = container.CreateChildContainer(attachToParent: false))\n    {\n    } // child1 will be disposed only once here.\n    \n    var child2 = container.CreateChildContainer();\n    var child3 = container.CreateChildContainer();\n} // using will dispose the parent along with child2 and child3.\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can safely dispose a child even if it's attached to its parent, in this case the parent's disposal will not dispose the already disposed child."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"using (var container = new StashboxContainer())\n{\n    using (var child1 = container.CreateChildContainer())\n    {\n    } // child1 will be disposed only once here.\n    \n    var child2 = container.CreateChildContainer();\n} // using will dispose only the parent and child2.\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},7470:(e,n,i)=>{i.d(n,{A:()=>a});var t=i(6540);const r={codeDescContainer:"codeDescContainer_ie8f",desc:"desc_jyqI",example:"example_eYlF"};var s=i(4848);function a(e){let{children:n}=e,i=t.Children.toArray(n).filter((e=>e));return(0,s.jsxs)("div",{className:r.codeDescContainer,children:[(0,s.jsx)("div",{className:r.desc,children:i[0]}),(0,s.jsx)("div",{className:r.example,children:i[1]})]})}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);